from flask import Flask, render_template, request, redirect, url_for, flash, send_file
import downloader
import requests
from bs4 import BeautifulSoup
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from webdriver_manager.chrome import ChromeDriverManager
import time
from validator import is_valid_cve_format, cve_exists

app = Flask(__name__)
app.secret_key = "your_secret_key"

def fetch_exploit_db_links(cve_id):
    # Set up Selenium WebDriver with headless option
    chrome_options = Options()
    chrome_options.add_argument("--headless")  # Run in headless mode
    chrome_options.add_argument("--disable-gpu")  # Disable GPU acceleration (optional)

    service = Service(ChromeDriverManager().install())
    driver = webdriver.Chrome(service=service, options=chrome_options)
    
    exploit_db_url = f"https://www.exploit-db.com/search?cve={cve_id}"
    driver.get(exploit_db_url)
    
    time.sleep(3)  # Wait for the page to load (adjust if needed)

    # Parse the page source
    soup = BeautifulSoup(driver.page_source, 'html.parser')
    driver.quit()
    
    # Find all links related to exploits
    exploit_links = []
    table = soup.find('table', {'id': 'exploits-table'})  # Ensure there's a table with id 'exploits-table'
    
    if table:
        rows = table.find_all('tr')[1:]  # Skip header row
        if rows:
            for row in rows:
                cols = row.find_all('td')
                if len(cols) > 1 and cols[1].find('a'):  # Ensure there's a link in the second column
                    link = cols[1].find('a')['href']
                    exploit_links.append(f"https://www.exploit-db.com{link}")
    else:
        exploit_links.append("No exploits table found.")
    
    return exploit_links

@app.route('/', methods=['GET', 'POST'])
def index():
    if request.method == 'POST':
        cve_id = request.form['cve_id']
        if cve_id:
            if not is_valid_cve_format(cve_id):
                flash("Invalid CVE ID format", "warning")
            else:
                status = cve_exists(cve_id)
                if status == True:
                    return redirect(url_for('result', cve_id=cve_id))
                else:
                    flash(f"CVE ID status: {status}", "warning")
        else:
            flash("Please enter a CVE ID", "warning")
    return render_template('index.html')

@app.route('/result/<cve_id>')
def result(cve_id):
    # Fetch details from NIST API
    nist_api_url = f"https://services.nvd.nist.gov/rest/json/cves/2.0?cveId={cve_id}"
    nist_response = requests.get(nist_api_url).json()

    if nist_response.get("totalResults", 0) == 0:
        flash(f"No information found for CVE ID {cve_id}", "warning")
        return redirect(url_for('index'))

    cve_data = nist_response['vulnerabilities'][0]['cve']
    description = cve_data['descriptions'][0]['value']
    score = cve_data['metrics']['cvssMetricV31'][0]['cvssData']['baseScore']
    cvss_severity = cve_data['metrics']['cvssMetricV31'][0]['cvssData']['baseSeverity']
    
    # Fetch and filter references (excluding broken ones)
    references = [
        ref['url'] for ref in cve_data['references']
        if 'Broken Link' not in ref.get('tags', [])
    ]

    # Fetch exploit links from Exploit-DB
    exploit_links = fetch_exploit_db_links(cve_id)

    return render_template('result.html', 
                           cve_id=cve_id, 
                           description=description, 
                           score=score, 
                           severity=cvss_severity, 
                           exploit_links=exploit_links,
                           references=references)

@app.route('/download_report/<cve_id>', methods=['POST'])
def download_report(cve_id):
    file_type = request.form['file_type']
    
    # Generate a summary report (dummy text for now)
    summary = f"Summary for {cve_id} - This is a placeholder summary."
    
    # Generate the report using the downloader module
    file_path = downloader.generate_report(cve_id, summary, file_type)
    
    # Send the file as a response to the client
    return send_file(file_path, as_attachment=True)

if __name__ == '__main__':
    app.run(debug=True)
